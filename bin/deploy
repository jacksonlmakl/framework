#!/bin/bash

# deploy.sh - Script to build Docker image for the framework and run as a scheduled service

# Exit on error
set -e

# Set variables
IMAGE_NAME="framework"
IMAGE_TAG="latest"
CONTAINER_NAME="framework-scheduler"

echo "🔍 Checking environment..."

# Function to check if Docker is installed
check_docker_installed() {
  if command -v docker &> /dev/null; then
    echo "Docker is already installed. Version:"
    docker --version
    return 0
  else
    return 1
  fi
}

# Function to install Docker on Debian-based systems (Ubuntu, Debian)
install_docker_debian() {
  echo "Installing Docker on Debian-based system..."
  
  # Update package index
  apt-get update
  
  # Install dependencies
  apt-get install -y \
    ca-certificates \
    curl \
    gnupg \
    lsb-release

  # Add Docker's official GPG key
  mkdir -p /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/$(lsb_release -is | tr '[:upper:]' '[:lower:]')/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
  
  # Set up the Docker repository
  echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$(lsb_release -is | tr '[:upper:]' '[:lower:]') \
    $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
  
  # Update apt package index
  apt-get update
  
  # Install Docker Engine
  apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
  
  # Add current user to the docker group
  usermod -aG docker root
  
  echo "Docker installed successfully"
}

# Function to install Docker on Red Hat-based systems (CentOS, Fedora, RHEL)
install_docker_redhat() {
  echo "Installing Docker on Red Hat-based system..."
  
  # Install required packages
  yum install -y yum-utils
  
  # Add Docker repository
  yum-config-manager --add-repo https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/docker-ce.repo
  
  # Install Docker Engine
  yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
  
  # Start Docker
  if command -v systemctl &> /dev/null; then
    systemctl start docker || service docker start
    systemctl enable docker || true
  elif command -v service &> /dev/null; then
    service docker start
  fi
  
  # Add current user to the docker group
  usermod -aG docker root
  
  echo "Docker installed successfully"
}

# Function to install Docker on Amazon Linux
install_docker_amazon() {
  echo "Installing Docker on Amazon Linux..."
  
  # Update packages
  amazon-linux-extras install docker -y
  
  # Start Docker
  service docker start || true
  
  # Enable Docker to start on boot
  if command -v systemctl &> /dev/null; then
    systemctl enable docker || true
  fi
  
  # Add current user to the docker group
  usermod -aG docker root
  
  echo "Docker installed successfully"
}

# Function to install Docker on macOS
install_docker_mac() {
  echo "For macOS, Docker Desktop is recommended."
  echo "This script will download the Docker Desktop installer for you."
  
  # Download Docker Desktop for Mac
  curl -L "https://desktop.docker.com/mac/main/amd64/Docker.dmg" -o ~/Downloads/Docker.dmg
  
  echo "Docker Desktop installer downloaded to ~/Downloads/Docker.dmg"
  echo "Please open the DMG file and drag Docker to Applications folder."
  
  # Attempt to mount the DMG and install
  hdiutil attach ~/Downloads/Docker.dmg
  
  echo "Docker installation file is mounted. Please complete the installation manually."
}

# Function to ensure Docker permissions
ensure_docker_permissions() {
  # First try with the current user
  if docker ps &> /dev/null; then
    echo "✅ Docker permissions are correctly set up."
    return 0
  fi
  
  echo "⚠️ Docker permission issues detected. Attempting to fix..."
  
  # Try to add the current user to the docker group again
  usermod -aG docker root || true
  
  # Try to apply group changes without requiring logout
  if command -v newgrp &> /dev/null; then
    echo "🔄 Applying group changes with newgrp..."
    # Since we can't restart the script within itself easily in non-interactive mode,
    # we'll just set USE_SUDO=1 and continue
    export USE_SUDO=1
  else
    # If newgrp is not available, try directly with sudo for this session
    echo "⚠️ Unable to automatically apply group changes"
    echo "🔄 Trying with sudo for this session..."
    export USE_SUDO=1
  fi
}

# Check if running as root
if [ "$(id -u)" -ne 0 ]; then
  echo "⚠️ This script requires root privileges to install Docker."
  echo "Please run with sudo or as root."
  exit 1
fi

# Main Docker installation script
if ! check_docker_installed; then
  echo "🔍 Docker not found. Installing..."
  
  # Detect operating system
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS
    install_docker_mac
    echo "⚠️ Please complete Docker installation on macOS and re-run this script"
    exit 1
  elif [[ -f /etc/os-release ]]; then
    # Linux distribution
    source /etc/os-release
    
    case "$ID" in
      ubuntu|debian|pop|elementary|mint|kali|zorin)
        install_docker_debian
        ;;
      centos|fedora|rhel|rocky|almalinux|ol)
        install_docker_redhat
        ;;
      amzn)
        install_docker_amazon
        ;;
      *)
        echo "⚠️ Unsupported Linux distribution: $ID"
        echo "Please install Docker manually for your distribution"
        exit 1
        ;;
    esac
    
    # Ensure Docker service is running - with fallbacks
    if command -v systemctl &> /dev/null; then
      systemctl start docker || service docker start || true
      systemctl enable docker || true
    elif command -v service &> /dev/null; then
      service docker start || true
    fi
    
    echo "✅ Docker installed. Ensuring permissions..."
    ensure_docker_permissions
  else
    echo "⚠️ Unsupported operating system"
    echo "Please install Docker manually for your operating system"
    exit 1
  fi
else
  # Docker is installed, but we need to check permissions
  ensure_docker_permissions
fi

# Variable to decide whether to use sudo for docker commands
USE_SUDO=${USE_SUDO:-0}

# Function to run docker commands with or without sudo as needed
run_docker() {
  if [ "$USE_SUDO" -eq 1 ]; then
    docker "$@" || sudo docker "$@"
  else
    docker "$@"
  fi
}

# Check if we're in the repository root directory
if [ ! -d "./bin" ] || [ ! -f "./bin/run" ]; then
    echo "❌ Error: This script should be run from the repository root directory."
    exit 1
fi

# Create Dockerfile with Ubuntu base that supports cron
echo "📝 Creating Dockerfile with scheduling support..."
cat > Dockerfile << 'EOL'
FROM ubuntu:22.04

# Set non-interactive mode for apt
ENV DEBIAN_FRONTEND=noninteractive

# Install Python and dependencies
RUN apt-get update && \
    apt-get install -y --no-install-recommends python3 python3-pip wget curl jq cron && \
    ln -s /usr/bin/python3 /usr/bin/python && \
    pip3 install --upgrade pip

# Install yq using pip
RUN pip install yq

# Set working directory
WORKDIR /app

# Copy requirements file
COPY module/requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the entire repository
COPY . .

# Make run script executable
RUN chmod +x ./bin/run

# Create a wrapper script to run with logging
RUN echo '#!/bin/bash\n\
cd /app && ./bin/run --run >> /app/cron.log 2>&1\n\
' > /app/run_scheduled.sh && chmod +x /app/run_scheduled.sh

# Create entrypoint script to set up cron and keep container running
RUN echo '#!/bin/bash\n\
\n\
# Extract schedule from controller.yaml if it exists\n\
if command -v yq &> /dev/null && [ -f "/app/controller.yaml" ] && yq -e ".schedule" "/app/controller.yaml" > /dev/null 2>&1; then\n\
    SCHEDULE=$(yq -r ".schedule" "/app/controller.yaml")\n\
    echo "📅 Found schedule in controller.yaml: $SCHEDULE"\n\
    \n\
    # Create cron job\n\
    echo "$SCHEDULE /app/run_scheduled.sh" > /etc/cron.d/framework-cron\n\
    chmod 0644 /etc/cron.d/framework-cron\n\
    crontab /etc/cron.d/framework-cron\n\
    echo "✅ Cron job installed"\n\
else\n\
    echo "⚠️ No schedule found in controller.yaml, will run once now and then stay idle"\n\
fi\n\
\n\
# Start cron service - do not use systemd which is not available in containers\n\
/etc/init.d/cron start\n\
echo "✅ Cron service started"\n\
\n\
# Run once immediately\n\
echo "🚀 Running initial execution..."\n\
/app/run_scheduled.sh\n\
\n\
# Keep container running\n\
echo "🔄 Container will remain running for scheduled executions"\n\
touch /app/cron.log\n\
tail -f /app/cron.log\n\
' > /app/entrypoint.sh && chmod +x /app/entrypoint.sh

# Set the entrypoint
ENTRYPOINT ["/app/entrypoint.sh"]
EOL

# Build the Docker image
echo "🔨 Building Docker image: $IMAGE_NAME:$IMAGE_TAG"
if run_docker build -t $IMAGE_NAME:$IMAGE_TAG .; then
    echo "✅ Docker image built successfully!"
    
    # Stop and remove existing container if it exists
    if run_docker ps -a | grep -q $CONTAINER_NAME; then
        echo "🔄 Stopping and removing existing container..."
        run_docker stop $CONTAINER_NAME || true
        run_docker rm $CONTAINER_NAME || true
    fi
    
    # Run the container with restart policy and volume mounts
    echo "🚀 Starting container with auto-restart..."
    run_docker run -d \
        --name $CONTAINER_NAME \
        --restart always \
        -v $(pwd)/controller.yaml:/app/controller.yaml \
        -v $(pwd)/model:/app/model \
        -v $(pwd)/data:/app/data \
        $IMAGE_NAME:$IMAGE_TAG
    
    echo ""
    echo "✅ Container is now running in the background with auto-restart"
    echo "📋 Container logs can be viewed with: ${USE_SUDO:+sudo }docker logs $CONTAINER_NAME"
    echo "📊 To stop the container: ${USE_SUDO:+sudo }docker stop $CONTAINER_NAME"
else
    echo "❌ Docker image build failed."
    exit 1
fi

