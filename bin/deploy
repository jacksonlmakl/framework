#!/bin/bash
# Ultra-lightweight deploy.sh - Maximum performance for Docker-in-Docker

# Set noninteractive mode for debconf
export DEBIAN_FRONTEND=noninteractive

# Exit on error
set -e

# Set variables
IMAGE_NAME="framework"
IMAGE_TAG="latest"
CONTAINER_NAME="framework-scheduler"

# Quick path to check Docker availability
if [ -S /var/run/docker.sock ]; then
    chmod 666 /var/run/docker.sock &>/dev/null || true
    if ! docker info &>/dev/null && ! command -v docker &>/dev/null; then
        # Install minimal Docker CLI only
        apt-get update -qq >/dev/null
        apt-get install -y -qq curl gnupg >/dev/null
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 2>/dev/null
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list >/dev/null
        apt-get update -qq >/dev/null
        apt-get install -y -qq docker-ce-cli >/dev/null
    fi
fi

# Check if we're in the repository root directory
if [ ! -d "./bin" ] || [ ! -f "./bin/run" ]; then
    echo "âŒ Error: This script should be run from the repository root directory."
    exit 1
fi

# Create Dockerfile with multi-stage build for extreme minimalism
echo "ğŸ“ Creating ultra-lightweight Dockerfile with multi-stage build..."

cat > Dockerfile << 'EOL'
# Stage 1: Build environment
FROM alpine:3.19 AS builder

# Install build dependencies
RUN apk add --no-cache python3 py3-pip

# Create app directory
WORKDIR /build

# Copy requirements file
COPY module/requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Install yq for YAML parsing
RUN pip install --no-cache-dir yq

# Stage 2: Runtime environment - super minimal!
FROM alpine:3.19

# Install only the absolute essentials
RUN apk add --no-cache python3 curl busybox-extras tzdata && \
    ln -sf python3 /usr/bin/python

# Set working directory
WORKDIR /app

# Copy Python packages from builder
COPY --from=builder /usr/lib/python3* /usr/lib/
COPY --from=builder /usr/bin/yq /usr/bin/

# Copy all your app files
COPY bin/run /app/bin/run
COPY module/ /app/module/

# Create necessary scripts
RUN mkdir -p /app/data /app/model && \
    chmod +x /app/bin/run && \
    echo '#!/bin/sh' > /app/run_scheduled.sh && \
    echo 'cd /app && ./bin/run --run >> /app/cron.log 2>&1' >> /app/run_scheduled.sh && \
    chmod +x /app/run_scheduled.sh && \
    # Tiny entrypoint script with BusyBox's crond
    echo '#!/bin/sh' > /app/entrypoint.sh && \
    echo 'set -e' >> /app/entrypoint.sh && \
    echo 'mkdir -p /etc/cron.d' >> /app/entrypoint.sh && \
    echo 'if [ -f "/app/controller.yaml" ]; then' >> /app/entrypoint.sh && \
    echo '  SCHEDULE=$(yq -r ".schedule" "/app/controller.yaml" 2>/dev/null || echo "")' >> /app/entrypoint.sh && \
    echo '  if [ ! -z "$SCHEDULE" ]; then' >> /app/entrypoint.sh && \
    echo '    echo "$SCHEDULE /app/run_scheduled.sh" > /etc/crontabs/root' >> /app/entrypoint.sh && \
    echo '    echo "âœ“ Cron job installed"' >> /app/entrypoint.sh && \
    echo '  fi' >> /app/entrypoint.sh && \
    echo 'fi' >> /app/entrypoint.sh && \
    echo 'crond -f -l 8 &' >> /app/entrypoint.sh && \
    echo '/app/run_scheduled.sh' >> /app/entrypoint.sh && \
    echo 'touch /app/cron.log && tail -f /app/cron.log' >> /app/entrypoint.sh && \
    chmod +x /app/entrypoint.sh

# Set the entrypoint
ENTRYPOINT ["/app/entrypoint.sh"]
EOL

# Use buildkit for faster builds
export DOCKER_BUILDKIT=1

# Build the Docker image with no output except errors
echo "ğŸ”¨ Building ultra-lightweight Docker image..."
if docker build -t $IMAGE_NAME:$IMAGE_TAG . > /dev/null; then
    echo "âœ… Docker image built successfully!"
    
    # Get image size for reporting
    IMAGE_SIZE=$(docker images --format "{{.Size}}" $IMAGE_NAME:$IMAGE_TAG)
    echo "ğŸ“Š Image size: $IMAGE_SIZE"
    
    # Stop and remove existing container if it exists - quiet mode
    docker stop $CONTAINER_NAME > /dev/null 2>&1 || true
    docker rm $CONTAINER_NAME > /dev/null 2>&1 || true
    
    # Run the container with restart policy and volume mounts
    echo "ğŸš€ Starting container with auto-restart..."
    docker run -d \
        --name $CONTAINER_NAME \
        --restart always \
        -v $(pwd)/controller.yaml:/app/controller.yaml \
        -v $(pwd)/model:/app/model \
        -v $(pwd)/data:/app/data \
        $IMAGE_NAME:$IMAGE_TAG > /dev/null
    
    echo "âœ… Container is now running in the background"
else
    echo "âŒ Docker image build failed."
    exit 1
fi
