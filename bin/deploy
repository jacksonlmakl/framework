#!/bin/bash
# Fast deploy.sh - Optimized for Docker-in-Docker performance

# Set noninteractive mode for debconf
export DEBIAN_FRONTEND=noninteractive

# Exit on error
set -e

# Set variables
IMAGE_NAME="framework"
IMAGE_TAG="latest"
CONTAINER_NAME="framework-scheduler"

# Function to check if we need Docker
need_docker() {
  # If Docker socket is already mounted and working, we don't need to install Docker
  if [ -S /var/run/docker.sock ] && docker info &>/dev/null; then
    echo "âœ… Host Docker socket is mounted and accessible"
    return 1  # We DON'T need to install Docker
  fi
  
  # If Docker is already installed and functional, we don't need to install it
  if command -v docker &>/dev/null && docker info &>/dev/null; then
    echo "âœ… Docker is already installed and working"
    return 1  # We DON'T need to install Docker
  fi
  
  return 0  # We DO need to install Docker
}

# Check if we're in the repository root directory
if [ ! -d "./bin" ] || [ ! -f "./bin/run" ]; then
    echo "âŒ Error: This script should be run from the repository root directory."
    exit 1
fi

# Quick path for mounted Docker socket
if [ -S /var/run/docker.sock ]; then
    echo "ğŸ” Found mounted Docker socket, trying to use it..."
    chmod 666 /var/run/docker.sock &>/dev/null || true
    
    if docker info &>/dev/null; then
        echo "âœ… Host Docker socket is working correctly"
    else
        echo "âš ï¸ Host Docker socket exists but can't connect to Docker daemon"
        echo "âš ï¸ This usually indicates a permission issue"
        
        # Try a quick fix for socket permissions
        chmod 666 /var/run/docker.sock &>/dev/null || true
        
        if ! docker info &>/dev/null && need_docker; then
            echo "ğŸ” Need to install Docker..."
            
            # Install Docker CLI only for quick path
            if ! command -v docker &>/dev/null; then
                echo "ğŸ“¦ Installing Docker CLI (fast path)..."
                apt-get update -qq >/dev/null
                apt-get install -y -qq apt-transport-https ca-certificates curl gnupg >/dev/null
                mkdir -p /etc/apt/keyrings 2>/dev/null || true
                curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg 2>/dev/null
                echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list >/dev/null
                apt-get update -qq >/dev/null
                apt-get install -y -qq docker-ce-cli >/dev/null
                echo "âœ… Docker CLI installed"
            fi
        fi
    fi
fi

# Create Dockerfile with Alpine base (much lighter than Ubuntu)
echo "ğŸ“ Creating lightweight Dockerfile with Alpine Linux..."

cat > Dockerfile << 'EOL'
FROM alpine:3.19

# Set working directory
WORKDIR /app

# Install required packages (combined into one RUN to reduce layers)
RUN apk add --no-cache \
    python3 \
    py3-pip \
    wget \
    curl \
    jq \
    dcron \
    bash \
    && ln -sf python3 /usr/bin/python \
    && pip3 install --no-cache-dir --upgrade pip \
    && pip3 install --no-cache-dir yq

# Copy requirements file
COPY module/requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the entire repository
COPY . .

# Make run script executable
RUN chmod +x ./bin/run

# Create a wrapper script to run with logging
RUN echo '#!/bin/sh\n\
cd /app && ./bin/run --run >> /app/cron.log 2>&1\n\
' > /app/run_scheduled.sh && chmod +x /app/run_scheduled.sh

# Create entrypoint script
RUN echo '#!/bin/sh' > /app/entrypoint.sh && \
    echo 'set -e' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo 'echo "ğŸš€ Setting up container..."' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Create required directories' >> /app/entrypoint.sh && \
    echo 'mkdir -p /etc/cron.d' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Create cron job from controller.yaml (if exists)' >> /app/entrypoint.sh && \
    echo 'if command -v yq > /dev/null && [ -f "/app/controller.yaml" ]; then' >> /app/entrypoint.sh && \
    echo '  SCHEDULE=$(yq -r ".schedule" "/app/controller.yaml" 2>/dev/null || echo "")' >> /app/entrypoint.sh && \
    echo '  if [ ! -z "$SCHEDULE" ]; then' >> /app/entrypoint.sh && \
    echo '    echo "ğŸ“… Found schedule in controller.yaml: $SCHEDULE"' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '    echo "$SCHEDULE /app/run_scheduled.sh" > /etc/cron.d/framework-cron' >> /app/entrypoint.sh && \
    echo '    chmod 0644 /etc/cron.d/framework-cron' >> /app/entrypoint.sh && \
    echo '    crontab /etc/cron.d/framework-cron' >> /app/entrypoint.sh && \
    echo '    echo "âœ… Cron job installed"' >> /app/entrypoint.sh && \
    echo '  else' >> /app/entrypoint.sh && \
    echo '    echo "âš ï¸ No schedule found in controller.yaml, will run once now and then stay idle"' >> /app/entrypoint.sh && \
    echo '  fi' >> /app/entrypoint.sh && \
    echo 'else' >> /app/entrypoint.sh && \
    echo '  echo "âš ï¸ No schedule found in controller.yaml, will run once now and then stay idle"' >> /app/entrypoint.sh && \
    echo 'fi' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Start cron daemon in background' >> /app/entrypoint.sh && \
    echo 'crond -b' >> /app/entrypoint.sh && \
    echo 'echo "âœ… Cron service started"' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Run once immediately' >> /app/entrypoint.sh && \
    echo 'echo "ğŸš€ Running initial execution..."' >> /app/entrypoint.sh && \
    echo '/app/run_scheduled.sh' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Keep container running' >> /app/entrypoint.sh && \
    echo 'echo "ğŸ”„ Container will remain running for scheduled executions"' >> /app/entrypoint.sh && \
    echo 'touch /app/cron.log' >> /app/entrypoint.sh && \
    echo 'tail -f /app/cron.log' >> /app/entrypoint.sh && \
    chmod +x /app/entrypoint.sh

# Set the entrypoint
ENTRYPOINT ["/app/entrypoint.sh"]
EOL

# Use buildkit for faster builds
export DOCKER_BUILDKIT=1

# Build the Docker image - with minimal output
echo "ğŸ”¨ Building Docker image: $IMAGE_NAME:$IMAGE_TAG"
if docker build -t $IMAGE_NAME:$IMAGE_TAG . > /dev/null; then
    echo "âœ… Docker image built successfully!"
    
    # Stop and remove existing container if it exists - quiet mode
    if docker ps -a -q --filter "name=$CONTAINER_NAME" | grep -q .; then
        echo "ğŸ”„ Stopping and removing existing container..."
        docker stop $CONTAINER_NAME > /dev/null 2>&1 || true
        docker rm $CONTAINER_NAME > /dev/null 2>&1 || true
    fi
    
    # Run the container with restart policy and volume mounts
    echo "ğŸš€ Starting container with auto-restart..."
    docker run -d \
        --name $CONTAINER_NAME \
        --restart always \
        -v $(pwd)/controller.yaml:/app/controller.yaml \
        -v $(pwd)/model:/app/model \
        -v $(pwd)/data:/app/data \
        -v /var/run/docker.sock:/var/run/docker.sock
        $IMAGE_NAME:$IMAGE_TAG > /dev/null
    
    echo ""
    echo "âœ… Container is now running in the background with auto-restart"
    echo "ğŸ“‹ Container logs can be viewed with: docker logs $CONTAINER_NAME"
    echo "ğŸ“Š To stop the container: docker stop $CONTAINER_NAME"
else
    echo "âŒ Docker image build failed."
    exit 1
fi
