#!/bin/bash

# deploy.sh - Script to build Docker image for the framework and run as a scheduled service
# Modified to work in Docker-in-Docker environments without systemd

# Set noninteractive mode for debconf to avoid terminal errors
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true
export DEBCONF_NOWARNINGS="yes"

# Exit on error
set -e

# Set variables
IMAGE_NAME="framework"
IMAGE_TAG="latest"
CONTAINER_NAME="framework-scheduler"

# Check if Docker is installed, if not install it
if ! command -v docker &> /dev/null; then
    echo "🔍 Docker not found. Installing Docker CLI..."
    
    # Update package lists
    apt-get update -qq
    
    # Install prerequisites
    apt-get install -y -qq apt-transport-https ca-certificates curl gnupg lsb-release
    
    # Add Docker's official GPG key
    mkdir -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    
    # Set up the Docker repository
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    # Install Docker CLI only (not the full engine)
    apt-get update -qq
    apt-get install -y -qq docker-ce-cli
    
    echo "✅ Docker CLI installed successfully"
    
    # Check if we're running inside a container
    if [ -f /.dockerenv ]; then
        echo "🐳 Detected Docker-in-Docker environment"
        
        # Check if Docker socket exists from host mount
        if [ ! -S /var/run/docker.sock ]; then
            echo "⚠️ Docker socket not found. Please run the container with '-v /var/run/docker.sock:/var/run/docker.sock'"
            echo "⚠️ Attempting to continue, but build may fail..."
        else
            # Fix permissions on Docker socket if needed
            chmod 666 /var/run/docker.sock 2>/dev/null || true
        fi
    fi
fi

# Check if we're in the repository root directory
if [ ! -d "./bin" ] || [ ! -f "./bin/run" ]; then
    echo "❌ Error: This script should be run from the repository root directory."
    exit 1
fi

# Create Dockerfile with Ubuntu base that supports cron
echo "📝 Creating Dockerfile with scheduling support..."

cat > Dockerfile << 'EOL'
FROM ubuntu:22.04

USER root

# Set non-interactive mode for apt
ENV DEBIAN_FRONTEND=noninteractive

# Install Python and dependencies including cron and jq
RUN apt-get update && \
    apt-get install -y --no-install-recommends python3 python3-pip wget curl jq cron && \
    ln -s /usr/bin/python3 /usr/bin/python && \
    pip3 install --upgrade pip

# Force `debconf` to avoid interactive mode
RUN echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections

# Install yq using pip
RUN pip install yq

# Set working directory
WORKDIR /app

# Copy requirements file
COPY module/requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the entire repository
COPY . .

# Make run script executable
RUN chmod +x ./bin/run

# Create a wrapper script to run with logging
RUN echo '#!/bin/bash\n\
cd /app && ./bin/run --run >> /app/cron.log 2>&1\n\
' > /app/run_scheduled.sh && chmod +x /app/run_scheduled.sh

# Create entrypoint script to set up cron and keep container running
RUN echo '#!/bin/bash
set -e  # Exit on error

# Set noninteractive mode for debconf
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true
export DEBCONF_NOWARNINGS="yes"

echo "🚀 Setting up container..."

# Ensure the container is running with correct permissions
if [[ "$EUID" -ne 0 ]]; then
  echo "❌ Error: This script must be run as root."
  exit 1
fi

# Create cron job from controller.yaml (if exists)
if command -v yq &> /dev/null && [ -f "/app/controller.yaml" ]; then
  SCHEDULE=$(yq -r ".schedule" "/app/controller.yaml" 2>/dev/null || echo "")
  if [ ! -z "$SCHEDULE" ]; then
    echo "📅 Found schedule in controller.yaml: $SCHEDULE"

    echo "$SCHEDULE /app/run_scheduled.sh" > /etc/cron.d/framework-cron
    chmod 0644 /etc/cron.d/framework-cron
    crontab /etc/cron.d/framework-cron
    echo "✅ Cron job installed"
  else
    echo "⚠️ No schedule found in controller.yaml, will run once now and then stay idle"
  fi
else
  echo "⚠️ No schedule found in controller.yaml, will run once now and then stay idle"
fi

# Start cron manually using init.d script (works in containers)
/etc/init.d/cron start 2>/dev/null || cron 2>/dev/null || true
echo "✅ Cron service started"

# Run once immediately
echo "🚀 Running initial execution..."
/app/run_scheduled.sh

# Keep container running
echo "🔄 Container will remain running for scheduled executions"
touch /app/cron.log
tail -f /app/cron.log
' > /app/entrypoint.sh && chmod +x /app/entrypoint.sh

# Set the entrypoint
ENTRYPOINT ["/app/entrypoint.sh"]
EOL

# Build the Docker image
echo "🔨 Building Docker image: $IMAGE_NAME:$IMAGE_TAG"
if docker build -t $IMAGE_NAME:$IMAGE_TAG .; then
    echo "✅ Docker image built successfully!"
    
    # Stop and remove existing container if it exists
    if docker ps -a | grep -q $CONTAINER_NAME; then
        echo "🔄 Stopping and removing existing container..."
        docker stop $CONTAINER_NAME || true
        docker rm $CONTAINER_NAME || true
    fi
    
    # Run the container with restart policy and volume mounts
    echo "🚀 Starting container with auto-restart..."
    docker run -d \
        --name $CONTAINER_NAME \
        --restart always \
        -v $(pwd)/controller.yaml:/app/controller.yaml \
        -v $(pwd)/model:/app/model \
        -v $(pwd)/data:/app/data \
        $IMAGE_NAME:$IMAGE_TAG
    
    echo ""
    echo "✅ Container is now running in the background with auto-restart"
    echo "📋 Container logs can be viewed with: docker logs $CONTAINER_NAME"
    echo "📊 To stop the container: docker stop $CONTAINER_NAME"
else
    echo "❌ Docker image build failed."
    exit 1
fi
