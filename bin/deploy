#!/bin/bash

# deploy.sh - Script to build Docker image for the framework and run as a scheduled service
# Modified to use lightweight Alpine Linux for better performance in Docker-in-Docker

# Set noninteractive mode for debconf to avoid terminal errors
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true
export DEBCONF_NOWARNINGS="yes"

# Exit on error
set -e

# Set variables
IMAGE_NAME="framework"
IMAGE_TAG="latest"
CONTAINER_NAME="framework-scheduler"

# Function to start Docker daemon inside the container
start_docker_daemon() {
  echo "ğŸš€ Starting Docker daemon inside the container..."
  
  # Install full Docker Engine if only CLI is installed
  if ! command -v dockerd &> /dev/null; then
    echo "ğŸ“¦ Installing Docker Engine..."
    apt-get update -qq
    apt-get install -y -qq docker-ce docker-ce-cli containerd.io
  fi
  
  # Create required directories
  mkdir -p /var/run /var/log
  
  # Start Docker daemon in the background
  dockerd > /var/log/dockerd.log 2>&1 &
  
  # Wait for Docker daemon to become available
  echo -n "â³ Waiting for Docker daemon to start"
  for i in {1..30}; do
    if docker info &> /dev/null; then
      echo " âœ…"
      echo "âœ… Docker daemon is now running"
      return 0
    fi
    echo -n "."
    sleep 1
  done
  
  echo " âŒ"
  echo "âŒ Failed to start Docker daemon. Check logs at /var/log/dockerd.log"
  return 1
}

# Check if Docker is installed, if not install it
if ! command -v docker &> /dev/null; then
    echo "ğŸ” Docker not found. Installing Docker CLI..."
    
    # Update package lists
    apt-get update -qq
    
    # Install prerequisites
    apt-get install -y -qq apt-transport-https ca-certificates curl gnupg lsb-release
    
    # Add Docker's official GPG key
    mkdir -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    
    # Set up the Docker repository
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    # Install Docker CLI only (not the full engine)
    apt-get update -qq
    apt-get install -y -qq docker-ce-cli
    
    echo "âœ… Docker CLI installed successfully"
fi

# Check if Docker daemon is running or needs to be started
if ! docker info &> /dev/null; then
    echo "ğŸ” Cannot connect to Docker daemon"
    
    # Check if we're running inside a container
    if [ -f /.dockerenv ]; then
        echo "ğŸ³ Detected Docker-in-Docker environment"
        
        # Check if Docker socket exists from host mount
        if [ -S /var/run/docker.sock ]; then
            echo "ğŸ” Docker socket exists but cannot connect"
            echo "âš ï¸ Attempting to fix socket permissions..."
            
            # Try to fix permissions on Docker socket
            chmod 666 /var/run/docker.sock 2>/dev/null
            
            # Check if that fixed the issue
            if ! docker info &> /dev/null; then
                echo "âŒ Still cannot connect to Docker daemon"
                echo "âš ï¸ The socket might be mounted but not accessible."
                
                # Ask user if they want to start Docker daemon inside the container
                echo "ğŸ”„ Starting Docker daemon inside the container (true DinD)..."
                start_docker_daemon
            else
                echo "âœ… Successfully connected to Docker daemon via socket"
            fi
        else
            echo "âŒ Docker socket not found at /var/run/docker.sock"
            echo "âš ï¸ Starting Docker daemon inside the container..."
            start_docker_daemon
            
            # Recommend the proper way to mount socket for future runs
            echo "â„¹ï¸ For better performance, consider mounting the host's Docker socket:"
            echo "â„¹ï¸ docker run -v /var/run/docker.sock:/var/run/docker.sock ..."
        fi
    else
        echo "ğŸ” Not in a container, but Docker daemon is not running"
        echo "ğŸ”„ Attempting to start Docker service..."
        
        # Try different methods to start Docker
        service docker start 2>/dev/null || /etc/init.d/docker start 2>/dev/null || start_docker_daemon
        
        # Check if that worked
        if ! docker info &> /dev/null; then
            echo "âŒ Failed to start Docker daemon"
            exit 1
        else
            echo "âœ… Docker daemon started successfully"
        fi
    fi
fi

# Check if we're in the repository root directory
if [ ! -d "./bin" ] || [ ! -f "./bin/run" ]; then
    echo "âŒ Error: This script should be run from the repository root directory."
    exit 1
fi

# Create Dockerfile with Alpine base that supports cron (much lighter than Ubuntu)
echo "ğŸ“ Creating lightweight Dockerfile with Alpine Linux..."

cat > Dockerfile << 'EOL'
FROM alpine:3.19

# Set working directory
WORKDIR /app

# Install required packages (combined into one RUN to reduce layers)
RUN apk add --no-cache \
    python3 \
    py3-pip \
    wget \
    curl \
    jq \
    dcron \
    bash \
    && ln -sf python3 /usr/bin/python \
    && pip3 install --no-cache-dir --upgrade pip \
    && pip3 install --no-cache-dir yq

# Copy requirements file
COPY module/requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the entire repository
COPY . .

# Make run script executable
RUN chmod +x ./bin/run

# Create a wrapper script to run with logging
RUN echo '#!/bin/sh\n\
cd /app && ./bin/run --run >> /app/cron.log 2>&1\n\
' > /app/run_scheduled.sh && chmod +x /app/run_scheduled.sh

# Create entrypoint script
RUN echo '#!/bin/sh' > /app/entrypoint.sh && \
    echo 'set -e' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo 'echo "ğŸš€ Setting up container..."' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Create required directories' >> /app/entrypoint.sh && \
    echo 'mkdir -p /etc/cron.d' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Create cron job from controller.yaml (if exists)' >> /app/entrypoint.sh && \
    echo 'if command -v yq > /dev/null && [ -f "/app/controller.yaml" ]; then' >> /app/entrypoint.sh && \
    echo '  SCHEDULE=$(yq -r ".schedule" "/app/controller.yaml" 2>/dev/null || echo "")' >> /app/entrypoint.sh && \
    echo '  if [ ! -z "$SCHEDULE" ]; then' >> /app/entrypoint.sh && \
    echo '    echo "ğŸ“… Found schedule in controller.yaml: $SCHEDULE"' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '    echo "$SCHEDULE /app/run_scheduled.sh" > /etc/cron.d/framework-cron' >> /app/entrypoint.sh && \
    echo '    chmod 0644 /etc/cron.d/framework-cron' >> /app/entrypoint.sh && \
    echo '    crontab /etc/cron.d/framework-cron' >> /app/entrypoint.sh && \
    echo '    echo "âœ… Cron job installed"' >> /app/entrypoint.sh && \
    echo '  else' >> /app/entrypoint.sh && \
    echo '    echo "âš ï¸ No schedule found in controller.yaml, will run once now and then stay idle"' >> /app/entrypoint.sh && \
    echo '  fi' >> /app/entrypoint.sh && \
    echo 'else' >> /app/entrypoint.sh && \
    echo '  echo "âš ï¸ No schedule found in controller.yaml, will run once now and then stay idle"' >> /app/entrypoint.sh && \
    echo 'fi' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Start cron daemon in background' >> /app/entrypoint.sh && \
    echo 'crond -b' >> /app/entrypoint.sh && \
    echo 'echo "âœ… Cron service started"' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Run once immediately' >> /app/entrypoint.sh && \
    echo 'echo "ğŸš€ Running initial execution..."' >> /app/entrypoint.sh && \
    echo '/app/run_scheduled.sh' >> /app/entrypoint.sh && \
    echo '' >> /app/entrypoint.sh && \
    echo '# Keep container running' >> /app/entrypoint.sh && \
    echo 'echo "ğŸ”„ Container will remain running for scheduled executions"' >> /app/entrypoint.sh && \
    echo 'touch /app/cron.log' >> /app/entrypoint.sh && \
    echo 'tail -f /app/cron.log' >> /app/entrypoint.sh && \
    chmod +x /app/entrypoint.sh

# Set the entrypoint
ENTRYPOINT ["/app/entrypoint.sh"]
EOL

# Build the Docker image
echo "ğŸ”¨ Building Docker image: $IMAGE_NAME:$IMAGE_TAG"
if docker build -t $IMAGE_NAME:$IMAGE_TAG .; then
    echo "âœ… Docker image built successfully!"
    
    # Stop and remove existing container if it exists
    if docker ps -a | grep -q $CONTAINER_NAME; then
        echo "ğŸ”„ Stopping and removing existing container..."
        docker stop $CONTAINER_NAME || true
        docker rm $CONTAINER_NAME || true
    fi
    
    # Run the container with restart policy and volume mounts
    echo "ğŸš€ Starting container with auto-restart..."
    docker run -d \
        --name $CONTAINER_NAME \
        --restart always \
        -v $(pwd)/controller.yaml:/app/controller.yaml \
        -v $(pwd)/model:/app/model \
        -v $(pwd)/data:/app/data \
        $IMAGE_NAME:$IMAGE_TAG
    
    echo ""
    echo "âœ… Container is now running in the background with auto-restart"
    echo "ğŸ“‹ Container logs can be viewed with: docker logs $CONTAINER_NAME"
    echo "ğŸ“Š To stop the container: docker stop $CONTAINER_NAME"
else
    echo "âŒ Docker image build failed."
    exit 1
fi
